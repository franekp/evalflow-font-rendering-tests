<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Font rendering tests</title>
    <style type="text/css">
        body {
            background-color: #1e1e1e;
            color: #e2bd6d;
        }
        .select-font {
            padding: 5px;
        }
        .select-font button {
            margin: 5px;
            padding: 5px;
            display: inline-block;
        }
        #main > div {
            padding: 20px;
        }
        #main .test-case {
            background-color: #252526;
            padding: 3px 12px;
            margin: 3px;
            display: inline-block;
        }
        #main #codelenses .test-case {
            display: block;
            margin: 10px;
        }
    </style>
  </head>
  <body>
    <div id="select-font">
        <button onclick="setFont('SF Pro')">San Francisco Pro</button>
        <button onclick="setFont('Segoe UI Variable')">Segoe UI</button>
        <button onclick="setFont('Ubuntu')">Ubuntu</button>
    </div>
    <div id="main">
        <div id="codelenses"></div>
        <div id="values"></div>
        <div id="strings"></div>
        <div id="brackets"></div>
    </div>
    <script src="font_rendering.js" type="text/javascript"></script>
    <script type="text/javascript">

        function renderUnderlineMacOS(text) {
            const lowline = '\u0332';
            const lowline2 = '\u0332\u0332';
            const lowline3 = '\u0332\u0332';
            const macron = '\u035F';
            const lowMacron = '\u02CD';
            const singleMacron = '\u0331';
            const singleMacron3 = '\u0331\u0331\u0331';
            const zero = '\u200C';  // U+200C ZERO WIDTH NON-JOINER
            const macron3 = '\u035F\u035F\u035F';

            const len = text.split('').length;

            const decide = (char, i) => {
                if (i + 1 >= len) {
                    if ('âŸ¨â€¥âŸ©'.includes(char) || char == 'â€¥') {
                        return char + zero + lowline2;
                    }
                    return char + lowline2;
                }
                if ('âŸ¨â€¥âŸ©'.includes(char) || char == 'â€¥') {
                    return char + zero + macron3;
                }
                return char + macron3;
            }

            return zero + macron + text.split('').map(decide).join('');
        }

        function renderUnderlineWindows(text) {
            const zero = '\u200C';  // U+200C ZERO WIDTH NON-JOINER

            const lowline1 = '\u0332';
            const macron1 = '\u035F';
            const lowline2 = '\u0332\u0332';
            const macron2 = '\u035F\u035F';
            const lowline3 = '\u0332\u0332\u0332';
            const macron3 = '\u035F\u035F\u035F';
            const lowline4 = '\u0332\u0332\u0332\u0332';
            const macron4 = '\u035F\u035F\u035F\u035F';
            const macron5 = '\u035F\u035F\u035F\u035F\u035F';

            const arr = text.split('')

            const decide = (char, i) => {
                if (i + 1 >= arr.length) {
                    if (char.match(/[a-z]/i) && char != 'g' && char != 'j') {
                        return char + lowline1;
                    }
                    return char;
                }
                if ('â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'.includes(char)) {
                    return char;
                }
                if ('â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'.includes(arr[i + 1])) {
                    if ('jg'.includes(char)) {
                        return char;
                    }
                    if (char.match(/[a-z]/i)) {
                        return char + zero + lowline1;
                    } else {
                        return char;
                    }
                }
                if (char == 'â€¥') {
                    return zero + macron5 + char + macron1;
                }
                if (char.match(/[A-Zwm]/) || char == 'â€¥') {
                    return char + zero + lowline1 + macron5;
                }
                return char + zero + macron3;
            }

            return zero + lowline1 + text.split('').map(decide).join('');
            return zero + macron3 + text.split('').map((char, i) => i + 1 < len ? char + zero + macron3 : char).join('');
        }

        function renderUnderlineLinux(text) {
            const zero = '\u200C';  // U+200C ZERO WIDTH NON-JOINER
            const macron3 = '\u035F\u035F\u035F';
            const len = text.split('').length;
            return zero + macron3 + text.split('').map((char, i) => i + 1 < len ? char + zero + macron3 : char).join('');
        }

        function renderUnderlineLinuxAlternative(text) {
            // We keep it as a backup, because it works quite well and doesn't rely
            // on inserting zero-width characters. Although, version that inserts
            // "U+200C ZERO WIDTH NON-JOINER" is visibly better.
            const lowline1 = '\u0332';
            const macron1 = '\u035F';
            const lowline2 = '\u0332\u0332';
            const macron2 = '\u035F\u035F';
            const lowline3 = '\u0332\u0332\u0332';
            const macron3 = '\u035F\u035F\u035F';
            const lowline4 = '\u0332\u0332\u0332\u0332';
            const macron4 = '\u035F\u035F\u035F\u035F';

            const transform = char => {
                if ('â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'.includes(char)) {
                    return char;
                }
                if (char == 'â€¥') {
                    return char + macron1
                }
                if ('jgqyâŸ¨â€¥âŸ©'.includes(char)) {
                    return char
                }
                return char + lowline3
            };

            const as = [''].concat(text.split(''));
            const bs = text.split('').concat(['']);

            const decide = (a, b) => {
                if (a == '') {
                    if (b == 'âŸ¨') return '';
                    if ('0123456789'.includes(b)) return lowline1;
                }
                if (b == '') {
                    if ('â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'.includes(a)) return '';
                    if ('jgqQpyâŸ¨â€¥âŸ©'.includes(a)) return '';
                }

                if ('jgqQpyâŸ¨â€¥âŸ©'.includes(a) && 'jgqQpyâŸ¨â€¥âŸ©'.includes(b)) {
                    return '';
                }
                if ('jgqQpyâŸ¨â€¥âŸ©'.includes(b)) {
                    return lowline1 + macron3;
                }
                if ('jgqQpyâŸ¨â€¥âŸ©'.includes(a)) {
                    return '';
                }

                if (a == 'âŸ¨') return macron1;
                if ('â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'.includes(a)) return '';

                if (a == '') return '';
                if (b == '') return lowline1;

                return lowline1 + macron1;
            };

            const separators = as.map((a, i) => decide(a, bs[i]));
            const chunks = as.map((a, i) => a + separators[i]);
            return chunks.join('');
        }

        function renderUnderline(fontName, text) {
            const renderers = {
                'SF Pro': renderUnderlineMacOS,
                'Segoe UI Variable': renderUnderlineWindows,
                'Ubuntu': renderUnderlineLinux,
            };
            return renderers[fontName](text);
        }

        function renderItalic(fontName, text) {
            const lowercase = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
            const uppercase = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
            const italicLowercase = ['ð˜¢', 'ð˜£', 'ð˜¤', 'ð˜¥', 'ð˜¦', 'ð˜§', 'ð˜¨', 'ð˜©', 'ð˜ª', 'ð˜«', 'ð˜¬', 'ð˜­', 'ð˜®', 'ð˜¯', 'ð˜°', 'ð˜±', 'ð˜²', 'ð˜³', 'ð˜´', 'ð˜µ', 'ð˜¶', 'ð˜·', 'ð˜¸', 'ð˜¹', 'ð˜º', 'ð˜»'];
            const italicUppercase = ['ð˜ˆ', 'ð˜‰', 'ð˜Š', 'ð˜‹', 'ð˜Œ', 'ð˜', 'ð˜Ž', 'ð˜', 'ð˜', 'ð˜‘', 'ð˜’', 'ð˜“', 'ð˜”', 'ð˜•', 'ð˜–', 'ð˜—', 'ð˜˜', 'ð˜™', 'ð˜š', 'ð˜›', 'ð˜œ', 'ð˜', 'ð˜ž', 'ð˜Ÿ', 'ð˜ ', 'ð˜¡'];
            
            return text.split('').map(char => {
                let index = lowercase.indexOf(char);
                if (index !== -1) return italicLowercase[index];
                
                index = uppercase.indexOf(char);
                if (index !== -1) return italicUppercase[index];
                
                return char; // Return unchanged if not a letter
            }).join('');
        }

        function setFont(fontName) {
            document.querySelector('#main').style.fontFamily = fontName;
            for (const preset of ['codelenses', 'values', 'strings', 'brackets']) {
                const box = document.getElementById(preset);
                box.innerHTML = '';
                for (const text of window.renderingTests[preset]) {
                    const elem = document.createElement('div');
                    elem.className = 'test-case';
                    // uncomment to test italicizing text
                    // const content = preset == 'codelenses' ? text : renderItalic(fontName, text);
                    const content = preset == 'codelenses' ? text : renderUnderline(fontName, text);
                    elem.appendChild(document.createTextNode(content));
                    box.appendChild(elem);
                }
            }
        }
    </script>
  </body>
</html>
